= Widgeon

Widgeon is a widget system for Ruby on Rails.

=== Installation

$ ./script/plugin install http://talia.discovery-project.eu/svn/talia/repository/widgeon/trunk

=== Uninstallation

$ ./script/plugin delete widgeon

Notice: this operation will *destroy* all your widgets.

== Using an existing widget

In your view files:
<%= widget(:widget_name) %>

You can also pass params:
<%= widget(:widget_name, :param_one => 'one', :param_two => 'two') %>

== Developing a widget

First create a widget (see related section), the process will create two files:
and helper and a class.
For convention all params passed to the <tt>widget</tt> method will be available
into the widget object.

Example:
  <%= widget(:sidebar, :entries => 1..3) %>
  
  @sidebar_widget.entries #=> 1..3

Now you can easily guess that in your helpers you can use an instance variable
called (by convention) with the 'underscored' name of the class
(HelloWorldWidget #=> @hello_world_widget).

Now I can image that it isn't enough for you ;-) and I know you want to
manipulate the params passed to #widget. Ok, I have a solution: implement
#before_render in your class and this will be called for you. :-P

Example:
  app/views/index.rhtml:
  <h1><%= widget(:greeter, :name => 'luca') %></h1>

  widgets/greeter_widget.rb:
  class GreeterWidget < Widgeon::Widget
    def on_init
      name = name.titleize
    end
  end

  app/views/widgets/greeter/_greeter.rhtml:
  Welcome <%= w.name %>!!
  
  The result will be:
  <h1>Welcome Luca!!</h1>

As you can see the widget is made available as <tt>w.</tt> in the templates. 
Basically, if you want to access the widget's methods and variables, just prefix
the name with <tt>w.</tt>.

When you write your widget code, remember that *rails helpers are available to
the widget methods* - you can write the widget methods in the same way that 
you write helpers. (For example, you could use <tt>url_for</tt> in a widget
method).

<tt>on_init</tt> is a special method that is called when the widget is 
initialized. All the options passed to the widget will be available in this method,
as well as the options from the config file.

=== Options

You can pass a hash of options to the <tt>widget()</tt> call. All options will
be set as class variables with read and write accessors. An option hash can
also be defined in a YAML file (named like the widget. The config options from
the file will be loaded into the widget automatically when it is rendered.

=== Remote calls

See also Widgeon::Helpers

Using the <tt>widget_remotelink</tt> helper, one can make a remote call to the 
current widget. The call will initialize the widget, but *not* call the
<tt>before_render</tt> method.

A remote call will then call the handler that has been defined inside the
widget's class. A handler can be defined like this:

  remote_call :my_handler do |page|
    # modifying code
  end

The page object can be used in the same way as in a RJS template.

=== Backlinks to widget

See also the Widgeon::Helpers page

Using the <tt>widget_backlink</tt> helper, you may create a backlink to an exsting widget.
The widget backlink will call the current widget, passing the given options to
it. 

It renders the widget in the "normal" way and replaces the widget's <tt><div></tt>
 element with new HTML; the widget's element is referenced by the widget id. 

The backlink will also work without Javascript; in this case the whole page will
be re-rendered.

In any case, the <tt>is_callback</tt> propery will be set on the widget. Using
this property, a widget may discover if it's rendered as a result of a backlink
(or as part of a page that is the result of a backlink).

=== Widget state

Inside the widget, the <tt>widget_session</tt> will be used. This is a hash
that will stored in the user's session between widget calls. The hash is
identified by the widget's id, thus it will be shared between all widgets with
the same id.

=== Stylesheets

You may include a stylesheet file with the name <tt><widget_name>.css</tt> in
a widget's directory. By default, the stylesheet will be rendered as
an inline <style> element in the HTML code. You can disable this
behaviour by setting <tt>Widgeon::Widget::inline_styles = false</tt>.

If you disable the inline styles, you will have to provide the widget's
CSS styles by another mechanism.
  
== Create a widget

  $ ./script/generate widget HelloWorld

This creates <tt>widgets/hello_world_widget.rb</tt> and
<tt>app/views/widgets/hello_world/_hello_world_widget.rhtml</tt>.

== Destroy a widget

  $ ./script/destroy widget HelloWorld

This deletes <tt>widgets/hello_world_widget.rb</tt> and
<tt>app/views/widgets/hello_world/_hello_world_widget.rhtml</tt>.